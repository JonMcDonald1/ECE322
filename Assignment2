#ifndef DECK_H
#define DECK_H

#include <stdlib.h>
#include "player.h"
#include "card.h"
#include <stdio.h>
#include <time.h>
/*
 * Structure: deck
 * ---------------
 *  An array of 52 cards.
 */
struct deck {
  struct card list[52]; 
  int top_card;
};



/* 
 * Variable: deck_instance
 * -----------------------
 *
 * Go Fish uses a single deck
 */
struct deck deck_instance;  // this is deck_instance of type deck
/*
 * Function: shuffle
 * --------------------
 *  Initializes deck_instance and shuffles it.
 *  Resets the deck if a prior game has been played.
 * 
 *  returns: 0 if no error, and non-zero on error

 */

int shuffle(){
char R[13]={'A','2','3','4','5','6','7','8','9','1','J','Q','K'};//ranks
char S[4]={'C','D','H','S'};	//suit		     						
//need to append all R to each S so "CA","C2","C3"....[0],[1],[2]
int element=0; // keeps track of elements in list

for (int i=0;i<4;i++){// all 4 suits
	for (int j=0;j<13;j++) {// all 13 ranks
// if the number 10 is drawn, it is represented as a 1 and 0 is appended	
//struct rank[2] is 2 char long so [0] and [1] can be used		
		deck_instance.list[element].suit=S[i]; // struct suite is 1 char
	if (R[j]=='1'){
// creates '10' kinda like deck_instance.list[counter].rank="10";
			deck_instance.list[element].rank[0]='1';
			deck_instance.list[element].rank[1]='0';        }
		
		if (R[j]!='1'){
			deck_instance.list[element].rank[0]=R[j];   //only 1 element used  
		  	deck_instance.list[element].rank[1]='\0';	} //may need this line

// chars use %c and \n is new line prints unshuffled deck
//printf("%c%c%c \n",deck_instance.list[element].suit,deck_instance.list[element].rank[0],deck_instance.list[element].rank[1]);
	element++;
}}
// end creating the deck

// %p is the pointer address so these are the pointer locations
//				printf("%p \n",deck_instance.list[0] );
// pointer prints 'nil' when out bounds
//				  printf("%p \n",deck_instance.list[53] ); 

// need to now shuffle the deck
int length= sizeof deck_instance.list / sizeof deck_instance.list[0]; // 52

for (int i=0;i<length;i++){
	srand ( time(NULL) );	// this creates the seed to randomize
	int randomElement=rand()%(52-i); //will swap every element with another element at least once, so position [0],..[52] will get swapped with some other element once  random 

struct card temp; // deck_instance is 3 char long so make 3 blank
//struct card temp={"","",""};
temp = deck_instance.list[i];
deck_instance.list[i] = deck_instance.list[randomElement];
deck_instance.list[randomElement]=temp;
}

// prints out new shuffled deck
//for (int i=0;i<length;i++){
//	printf("%c%c%c \n",deck_instance.list[i].suit,deck_instance.list[i].rank[0],deck_instance.list[i].rank[1]); }

deck_instance.top_card=length;//52  set to use for to count
//printf("deck instance length: %d \n",deck_instance.top_card);


printf("Shuffling deck... \n \n");
return 0; // 0 returned when it runs all the way thru
}

/*
 * Function: deal_player_cards
 * ---------------------------
 *  Deal 7 random cards to the player specified in the function.
 *  Remove the dealt cards from the deck. 
 *
 *  target: pointer to the player to be dealt cards
 *
 *  returns: 0 if no error, and non-zero on error
 */

/// since it is now shuffled, take the top 7 cards and give them to a user

int deal_player_cards(struct player* target){
	for(int i=1;i<=7;i++){
				add_card(target, &deck_instance.list[deck_instance.top_card-1] );	
				deck_instance.top_card=deck_instance.top_card -1;// decrement deck size	because taking cards from DECK
	}
}

/*
 * Function: next_card
 * -------------------
 *  Return a pointer to the top card on the deck.
 *  Removes that card from the deck. 
 *
 *  returns: pointer to the top card on the deck.
 */
struct card* next_card( ){
	int top=deck_instance.top_card-1;
	//int next_card_pointer=&deck_instance.list[top]; //& symbol returns adress of the top card
	//free(&deck_instance.list[top])	;

//delete next_card_pointer;// free memory by deleting adress
	//next_card_pointer=NULL;// point dangling pointer to null
	//return next_card_pointer;
}
/* 
 * Function: size
 * --------------
 *  Return the number of cards left in the current deck.
 *
 *  returns: number of cards left in the deck.
 */

size_t deck_size( ){
	int deck_size=52;// deck is always 52
	//the user and computer hand size changes over the game
	int subtract=user.hand_size+computer.hand_size; // user and computer size 	change over time
	int smaller_deck=deck_size-subtract;
	printf("smaller deck size: %d\n",smaller_deck);
	return smaller_deck;
}

/// EXTRA FUNCTION CREATED TO PRINT THE PLAYERS DECK
void printDeck(struct player* node){
		//keep count of turns
	if (node==&user){
printf("Player 1's Hand - ");
}
if (node==&computer){
printf("Player 2's Hand - ");
}
		//original hand		
		int *reset=node->card_list;        //set temp pointer to start 
		while (node->card_list != NULL){
                printf("%s ", node->card_list);
                node->card_list = node->card_list->next;
 		}
		//reset the hand to the beggining node using temp
		printf("\n");		
		node->card_list=reset;
		
}



#endif



-----------------------------------------------------------------------------------------------
#ifndef PLAYER_H
#define PLAYER_H

#include <stdlib.h>
#include <stdio.h>
#include "card.h"
#include "deck.h"
#include <stdbool.h>
#include <string.h>
/*
 * Structure: player
 * -----------------
 *  Each player holds some number of cards in their hand
 *  Each player can have at most 7 "books" before winning 
 */
struct player {
  struct hand* card_list;
  char book[7];
  size_t hand_size;
  size_t book_size;// created to increment
};

/* 
 * Instance Variables: user, computer
 * ----------------------------------
 *
 *  We only support 2 users: a human and a computer
 */
struct player user;
struct player computer;
//  imagine 7 hands, each hand has a different card  each hand is a node with 1 card, and that hand points to the next 
/*
 * Function: add_card
 * -------------------
 *  Add a new card to the player's hand. 
 *
 *  target: the target player
 *  new_card: pointer to the new card to add
 *
 *  returns: return 0 if no error, non-zero otherwise
 */

//2 different ways of printing the card 
//printf("answer: %c%c%c \n ",(*new_card).suit ,(*new_card).rank[0],(*new_card).rank[1]   );
//printf("card added: %c%c%c \n ",  new_card->suit ,  new_card->rank[0],new_card->rank[1]   );

int  add_card(struct player* target, struct card* new_card){
//create node new_card and add this node to the end of the players deck which is a linked list of nodes

if (target == NULL || new_card==NULL)
{				//fail case
printf("unable to allocate memory for target \n");
	return -1;
}

// card list is pointer to head of linked list
// looking at specific players deck

//(pointer name)-->(variable name)

struct hand* new_item=NULL; //used to create the node of the card being added
new_item  = (struct hand*)malloc(sizeof(struct hand));
if (new_item == NULL)
{				//fail case
printf("unable to allocate memory for new_item \n");
	return -1;
}
//creates new_item node BASED ON HAND, WHICH HAS TOP AND NEXT
new_item->top = *new_card;// sets the argument new card to a node
new_item->next= NULL; // will be last element

struct hand* head=target->card_list;
// or can do struct hand* head=target->card_list
//if initial node does is null set it to the null item
if(target->card_list == NULL){
        target->card_list = new_item;
}
else{	
        //head = target->card_list;
		//traverse the list and set the current head to the next 
        while(head->next != NULL){
                head = head->next;    
	  }  //since traversed, set the next to the node
        head->next = new_item;
	}
target->hand_size = target->hand_size+1;// increment hand size
// may need to take out deck_instance.top since you can add card to other hands
//return head;
return 0; // no error
}


/*
 * Function: remove_card
 * ---------------------
 *  Remove a card from the player's hand. 
 *
 *  target: the target player
 *  old_card: pointer to the old card to remove
 *
 *  returns: return 0 if no error, non-zero otherwise
 */
/*
int remove_card(struct player* target, struct card* old_card){
//make structs
struct hand* head = target->card_list;
struct hand* remove = old_card;// old card is the node inside the same list

int *reset = target->card_list;    

//base case: One of inputs is null, code error
if (head == NULL || remove == NULL){
	return -1;
}

//First case: Node to be deleted is head node , 
if (head == remove){
	head = remove->next;
	target->card_list = head; //redefine front
}

//Second Case: Node to be deleted is last node
if (remove->next == NULL){	//check if last node->next=NULL
	while (target->card_list != NULL){      //traverse through card_list
//if target->card_list->next->nex is NULL then we delete the last node by setting target->card_list->next to NULL by skipping over the last node
		if(target->card_list->next->next == NULL){
            	    target->card_list->next = target->card_list->next->next;
  		}
   	target->card_list = target->card_list->next; //traverse iteration
 	}
}
//Third case: any middle node
if (remove != head && remove->next != NULL){
	while (target->card_list != NULL){	//traverse through card_list
//if target->card_list->next is the card you want to remove, then set "->next"   card to be the "->next->next" This will skip over the old_card in LL
	if(target->card_list->next == remove){	
		target->card_list->next = target->card_list->next->next;
  	}
	 target->card_list = target->card_list->next; //traverse iteration
 	}
}

//reset pointer
target->card_list=reset;

//free memory
free(remove);
return;
}

*/

/*
 * Function: check_add_book
 * ------------------------
 *  Check if a player has all 4 cards of the same rank.
 *  If so, remove those cards from the hand, and add the rank to the book.
 *  Returns after finding one matching set of 4, so should be called after adding each a new card.
 * 
 *  target: pointer to the player to check
 *  
 *  Return: a char that indicates the book that was added; return 0 if no book added.
 */

/*
char check_add_book(struct player* target){
	//10 is not included, seperate case
	char R[12]={'A','2','3','4','5','6','7','8','9','J','Q','K'};

	char counter = 0;

for (int i=0;i<12;i++){		//iterate every case except 10
	while (target->card_list != NULL){
		//need to make a string of the card ur checking without the suit
//the card being checked in the hand changes so the check changes too		
		card_string=target->card_list->top;	//S9-->9 removes suit
		char check=card_string->rank[0]

		//S9 --> 9 =='9' then counter = counter+1
	if (check == R[i]){
		counter = counter + 1
	}// end if statement 
		target->card_list = target_card_list->next;
	}//end while loop

	// when the counter is 4 go thru hand and remove all 4 
	if (counter == 4){
		while (target->card_list != NULL){
	//checks to see if characters match, since 4 are in list, remove all
               		if (check == R[i]){
				remove_card(&user, &reset->top);
			}// end check
			target->card_list=target->card_list->next;
		}//end while
	target.book[book_size]=R[i];// add that char to the book
	target.book_size=target.book_size+1;// increment to next location
  	}//if counter end

 }//for loop for 12/13 cases


int ten;// seperately checks if the number 10 appears 4 times
while (target->card_list != NULL){
	card_string=target->card_list->top;
				//check if rank==10 case
	char check_ten[2]=card_string->rank[0],card_string->rank[1]

                if (check_ten == "10"){
                        ten = ten + 1;
                                                    }
                target->card_list = target_card_list->next;
                                         }
// if 10 appears 4 times in deck, remove it and add to book
if (ten == 4){
	while (target->card_list != NULL){
          	if (check_ten=="10"){
			//remove head of card_list since 4 are found
               remove_card(&user,&reset->top 							    }
                         target->card_list=target->card_list->next;
                                                            
                                                 }
	target.book[book_size]="10";  // add 10 to the book
	target.book_size=target.book_size+1;// increment book

     
  }//if counter

}//function

*/

/*
 * Function: search
 * ----------------
 *  Search a player's hand for a requested rank.
 *  
 *  rank: the rank to search for
 *  target: the player (and their hand) to search
 *
 *  Return: If the player has a card of that rank, return 1, else return 0
 */
//*************************DONE********************************************
		//search(&computer,rank);
int search(struct player* target, char*rank){

int *reset=target->card_list;        //set temp pointer to start

//printf("looking for ranks %s\n ",rank);// RANK IS A STRING CHAR AND IT ONLY INPUTS THE 1st CHAR SO NEED TO CHECK IF RANK=1 INSTEAD OF 10

//use strcmp to see if rank="1" which is really 10
char ten[100]="1";
//printf("ten: %s",ten);

if (strcmp(rank,ten)==0){  // check is the string of rank and ten are both 1
	//printf("the rank was 10!\n");
	char suit1[100];
	strcpy(suit1,"C");	// creates C10
	strcat(suit1,rank);
	strcat(suit1,"0");
//	printf("%s\n",suit1);

	char suit2[100];
	strcpy(suit2,"D");
	strcat(suit2,rank);	// creates D10
	strcat(suit2,"0");
//	printf("%s\n",suit2);

	char suit3[100];
	strcpy(suit3,"H");	// creates H10
	strcat(suit3,rank);
	strcat(suit3,"0");
//	printf("%s\n",suit3);

	char suit4[100];
	strcpy(suit4,"S");
	strcat(suit4,rank);	// creates S10
	strcat(suit4,"0");
//	printf("%s\n",suit4);

	int count=0;
	bool check=false;

	while (target->card_list != NULL){

//suit#==target->card_list
//strcmp is 0 when the strings are identical.so checks if this happens
if(strcmp(suit1,target->card_list)==0){
	printf("%s matched with %s \n",suit1,target->card_list);
	check=true;}
if(strcmp(suit2,target->card_list)==0){
	printf("%s matched with %s \n",suit2,target->card_list);
	check=true;}
if(strcmp(suit3,target->card_list)==0){
	printf("%s matched with %s \n",suit3,target->card_list);
	check=true;}
if(strcmp(suit4,target->card_list)==0){
	printf("%s matched with %s \n",suit4,target->card_list);
	check=true;}

//	printf("%s did not match with %s\n",suit1,target->card_list);
//	printf("%s did not match with %s\n",suit2,target->card_list);
//	printf("%s did not match with %s\n",suit3,target->card_list);
//	printf("%s did not match with %s\n",suit4,target->card_list);
//	count++;
//	printf("card count: %d \n",count); // make sure runs thru 7 cards
	target->card_list=target->card_list->next; // iterate to nextcard
}// end while loop

target->card_list=reset;//reset deck so if the error occurs, then it can start from the begging again.
if (check==true){
//	printf("match\n");
	return 1;}
if (check==false){
//	printf("fail\n");
	return 0;}


} // end if



else{
// CASE WHEN RANK IS NOT 10

char suit1[100];
strcpy(suit1,"C");// creates 1 string 
strcat(suit1,rank);// combine the suit and rank string
//printf("%s\n",suit1);

char suit2[100];
strcpy(suit2,"D");/// each one of these combines the suit char with the rank
strcat(suit2,rank);	// so it creates C5,D5,H5,S5 if rank input=5
//printf("%s\n",suit2);

char suit3[100];
strcpy(suit3,"H");
strcat(suit3,rank);
//printf("%s\n",suit3);

char suit4[100];
strcpy(suit4,"S");
strcat(suit4,rank);
//printf("%s\n",suit4);

int count=0;
bool check=false;
//checks if any of those 4 ranks are in the deck, if so , return 1

while (target->card_list != NULL){

//suit#==target->card_list
//strcmp is 0 when the strings are identical.so checks if this happens
if(strcmp(suit1,target->card_list)==0){
//	printf("%s matched with %s \n",suit1,target->card_list);
	check=true;}
if(strcmp(suit2,target->card_list)==0){
//	printf("%s matched with %s \n",suit2,target->card_list);
	check=true;}
if(strcmp(suit3,target->card_list)==0){
//	printf("%s matched with %s \n",suit3,target->card_list);
	check=true;}
if(strcmp(suit4,target->card_list)==0){
//	printf("%s matched with %s \n",suit4,target->card_list);
	check=true;}

//	printf("%s did not match with %s\n",suit1,target->card_list);
//	printf("%s did not match with %s\n",suit2,target->card_list);
//	printf("%s did not match with %s\n",suit3,target->card_list);
//	printf("%s did not match with %s\n",suit4,target->card_list);
//	count++;
//	printf("card count: %d \n",count); // make sure runs thru 7 cards
	target->card_list=target->card_list->next;
}// end while loop

target->card_list=reset;//reset deck so if the error occurs, then it can start from the begging again.
if (check==true){
//	printf("match\n");
	return 1;}
if (check==false){
//	printf("fail\n");
	return 0;}

// if none of the if statements returned 1, then it returns 0

} //end else



}// end search




/*
 * Function: transfer_cards
 * ------------------------
 *   Transfer cards of a given rank from the source player's 
 *   hand to the destination player's hand. Remove transferred
 *   cards from the source player's hand. Add transferred cards
 *   to the destination player's hand.
 *   
 *   src: a pointer to the source player
 *   dest: a pointer to the destination player
 *   rank: the rank to transfer
 *
 *   Return: 0 if no cards found/transferred, <0 if error, otherwise 
 *   return value indicates number of cards transferred
 */   

/*
int transfer_cards(struct player* src, struct player* dest, char rank){
// 2 pointers for the players hands
struct hand* recieving_card=dest->card_list;// the destination recieves
struct hand* losing_card=src->card_list;  // the source is giving their card
char suit1='C';
strcat(suit1,rank); //CA,C2,C3..C10..CQ

char suit2='D';
strcat(suit2,rank);//DA,D2,D3..D10..DQ

char suit3='H';
strcat(suit3,rank);//HA,H2,H3..H10..HQ

char suit4='S';
strcat(suit4,rank);//SA,S2,s3..S10..SQ
// go thru source deck to remove the card being asked for an
while (src->card_list != NULL){
	
//printf("%s",src->card_list) points to the entire string at that head
// checks to see if any 4suits are in the hand of the source
//if C2=D2 or H2=D2 or S2=D2 or D2=D2 , since 1 of them is true, remove that pointer and add it to the other deck 
	if (suit1 || suit2 || suit3 || suit4 ==src->card_list){
		
		//-> top is the location of the node that is being altered
		remove_card(&src,&src->card_list->top);		
		add_card(&dest,&dest->card_list->top);
			}		
		}
	//go to next node in SOURCE HAND to check for rest 
	src->card_list=src->card_list->next;

} 
*/

/*
 * Function: game_over
 * -------------------
 *   Boolean function to check if a player has 7 books yet
 *   and the game is over
 *
 *   target: the player to check
 *   
 *   Return: 1 if game is over, 0 if game is not over
 */
int game_over(struct player* target);
// if the 7th entry char in book is full, then set the game to over
//bool game_over=false;
//if(target.){
//	bool game_over=true; }
//if (game_over==true){
//	return -1; }
//else{
//	return 0;}


/* 
 * Function: reset_player
 * ----------------------
 *
 *   Reset player by free'ing any memory of cards remaining in hand,
 *   and re-initializes the book.  Used when playing a new game.
 * 
 *   target: player to reset
 * 
 *   Return: 0 if no error, and non-zero on error.
 */
int reset_player(struct player* target);

/* 
 * Function: computer_play
 * -----------------------
 *
 *   Select a rank randomly to play this turn. The player must have at least
 *   one card of the selected rank in their hand.
 *
 *   target: the player's hand to select from
 *
 *   Rank: return a valid selected rank
 */
char computer_play(struct player* target){
// so there are 13 possible ranks to choose from
// create a list of the 13 ranks, shuffle it, and then go down the list and select rank and if it does not exist in the user hand then go to the next rank in the random shuffled list 
//USE THE SHUFFLE CODE TO MAKE A NON SHUFFLED LIST OF RANKS, THEN SHUFFLE IT, THEN SEARCH FIRST ELEMENT WITH SEARCH AND THEN CH

// i think a struct may be easier idk

//comp_list = list[13];
//for(int i=0;i<13;i++){
//comp_list[i]=
}



while(search(&computer,rank[i])==0){
	printf("Error - must have at least one card from rank to play \n");
	printf("Player 1's turn, enter a Rank: ");
	i++;
}

 // returns one of ranks->A,2,3.6..Q,K
printf("legal rank inside user_play is: %c\n",*rank);
return *rank; // returns valid selected rank

}

/* 
 * Function: user_play
 * -------------------
 *
 *   Read standard input to get rank user wishes to play.  Must perform error
 *   checking to make sure at least one card in the player's hand is of the 
 *   requested rank.  If not, print out "Error - must have at least one card from rank to play"
 *   and then re-prompt the user.
 *
 *   target: the player's hand to check
 * 
 *   returns: return a valid selected rank
 */   




///***************************DONE********************************
char user_play(struct player* target){

//so scanf will only take the first value, so when 10, check if rank=1 because it sets it as 1  and then concatenate the 0 to end if 1
char rank[20];
printf("Player 1's turn, enter a Rank: ");
scanf("%c",rank);
// keeps on running if it fails, because failing is not an option!
//==0 is the fail case for not finding anything in search function
//use search function to see if the input is legal
while(search(&computer,rank)==0){
	printf("Error - must have at least one card from rank to play \n");
	printf("Player 1's turn, enter a Rank: ");
	scanf(" %c",rank); //waits for input the space eliminates 2x printing
}

 // returns one of ranks->A,2,3.6..Q,K
printf("legal rank inside user_play is: %c\n",*rank);
return *rank; // returns valid selected rank
}


#endif
----------------------------------------------------------------------------------------




#include "deck.h"
#include "player.h"
//#include "<stdio.h>"
int main(int args, char* argv[]) 
{
	shuffle();
	deal_player_cards(&user);     //works
	printDeck(&user);
	//printDeck refers to an updated deck everytime it is called 
	deal_player_cards(&computer); // works
	printDeck(&computer);		//works
	//deck_size();			// works 52-7-7=38
	//search(&computer,rank); // return value searching works 100%
	
	char rank;	 					
	
	//Enter into an endless loop until the game is over
//	while(1){
		//user goes first
		rank=user_play(&user); // get input from user works 100% with 10!
		printf("the legal rank is: %s\n",&rank); //rank outside use &

		//if(search(&computer,rank)){// if a single card from rank is found, go thru the entire deck and then remove all of them 
		//printf("the search worked\n");
		// CALL THE TRANSFER CARDS FUNCTION SINCE CARDS ARE FOUND
		// the computer is giving the user the cards that match rank
		//transfer_cards(&computer,&user,rank);

//		} 
			// rank not found in other hand, go fish
//		else{
	// take a card from the deck and give it to the user so &user
//add_card(&user, &deck_instance.list[deck_instance.top_card-1] );	
//	deck_instance.top_card=deck_instance.top_card -1;// decrement deck
//		}
//-----------------------------------------------------------
/*

		


		rank=computer_play(&computer); // get input from computer
		//check of the user has any suits that match that rank
		if( search(&user,rank) ){
		// CALL THE TRANSFER CARDS FUNCTION SINCE CARDS ARE FOUND
		// the user is giving the computer the cards that match rank
		transfer_cards(&user,&computer,rank);
		}
			// rank not found in other hand, go fish
		else{   	
	// take a card from the deck and give it to the computer so &computer
add_card(&computer, &deck_instance.list[deck_instance.top_card-1] );	
	deck_instance.top_card=deck_instance.top_card -1;// decrement deck
//		} end while
/*


		//check whether game is over
		int prompt=0;
		if(game_over(&user))	{
	fprintf(stderr,"Congratulations! You beat the computer player. \n");
		}
			prompt=prompt_next();
		else if(game_over(&computer)){
fprintf(stderr,"Sorry! You lose the game to the computer player. \n");
			prompt=prompt_next();
			}

	











	//for (int i=0;i<52;i++){
//	printf("%c%c%c \n",deck_instance.list[i].suit,deck_instance.list[i].rank[0],deck_instance.list[i].rank[1]);}


	//printf("deck instance top card :%d\n ",deck_instance.top_card);
	//printf("answer outside %c%c%c \n ",deck_instance.list[deck_instance.top_card-1].suit , deck_instance.list[deck_instance.top_card-1].rank[0] ,            deck_instance.list[deck_instance.top_card-1].rank[1]);


	add_card(&user, &deck_instance.list[deck_instance.top_card-1] );
	deck_instance.top_card=deck_instance.top_card -1;
	add_card(&user, &deck_instance.list[deck_instance.top_card-1] );
	deck_instance.top_card=deck_instance.top_card -1;
	add_card(&user, &deck_instance.list[deck_instance.top_card-1] );
	deck_instance.top_card=deck_instance.top_card -1;
	printf("\n");	
	printf("users hand size: %d \n",user.hand_size);
//add_card(&computer, &deck_instance.list[deck_instance.top_card-1] );
	//deck_instance.top_card=deck_instance.top_card -1;	
	//printf("computer hand size: %d \n",computer.hand_size);	
			
	printf("\n\n");

	printDeck(&user);
	printf("\n");
	add_card(&user, &deck_instance.list[deck_instance.top_card-1] );
	deck_instance.top_card=deck_instance.top_card -1;
	printf("\n");
	printDeck(&user);



*/
}






